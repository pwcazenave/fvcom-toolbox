<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of get_HYCOM_forcing</title>
  <meta name="keywords" content="get_HYCOM_forcing">
  <meta name="description" content="Get mean flow, temperature, salinity, surface elevation and denstiy data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">fvcom_prepro</a> &gt; get_HYCOM_forcing.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for fvcom_prepro&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>get_HYCOM_forcing
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Get mean flow, temperature, salinity, surface elevation and denstiy data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function data = get_HYCOM_forcing(Mobj, modelTime, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Get mean flow, temperature, salinity, surface elevation and denstiy data
 from HYCOM model outputs through their OPeNDAP server.

 data = get_HYCOM_forcing(Mobj, modelTime)

 DESCRIPTION:
   Using OPeNDAP, extract the necessary parameters to create an FVCOM
   forcing file.

 INPUT:
   Mobj - MATLAB mesh object with the following fields:
           - have_lonlat - boolean indicating whether lat/long values are
           present in Mobj.
           - lon, lat - longitude and latitudes of the model grid nodes.
   modelTime - Modified Julian Date start and end times
   varlist - [optional] cell array of variables to download. Use HYCOM
       names (e.g. ssh, salinity, temperature, u, v). If omitted,
       downloads salinity, temperature and ssh only.
   three - [optional] boolean. Set to true to download the 3 hourly data
       for the period 1992/10/2 to 2008/09/18 (inclusive). Defaults to
       false and downloads only the daily data.

 OUTPUT:
   data - struct of the data necessary to force FVCOM. These can be
   interpolated onto the unstructured grid in Mobj using grid2fvcom.m.

 The parameters (and the corresponding field names returned) which are
 obtained from the HYCOM data are:
     - time [MT]
     - temperature [temperature]
     - salinity [salinity]
     - u mean flow component [u]
     - v mean flow component [v]
     - daily mean sea surface height [ssh]

 EXAMPLE USAGE:
   To download the default parameters (temperature, salinity and ssh):

       modeltime = [55561, 55591]; % time period in Modified Julian Days
       hycom = get_HYCOM_forcing(Mobj, modeltime);

   To download only sea surface height:

       modeltime = [55561, 55591]; % time period in Modified Julian Days
       hycom = get_HYCOM_forcing(Mobj, modeltime, {'ssh'})

 Author(s)
   Pierre Cazenave (Plymouth Marine Laboratory)

 Revision history:
   2013-01-31 First version.
   2013-08-19 Make some more progress in getting this working. Mainly
   change the way the dates are handled to form the relevant URL for
   downloading the data.
   2013-09-03 More incremetal changes to get the function working. At the
   moment, I'm ignoring the old OPeNDAP toolbox for reading the data from
   the HYCOM OPeNDAP server.
   2013-09-05 It's working! Also add a data.time variable with the time
   stamps from the HYCOM data.
   2013-12-02 Add sea surface height to the list of variables that can be
   downloaded.
   2013-12-09 Add ability to specify particular variables to download.
   2013-12-12 Fix the handling of the variable input list of field names.
   2015-05-21 Add support for the Global Reanalysis data which extends
   coverage back to 1992 (previously limited to 2008 with the Global
   Analysis data). The Global Analysis data is used from 2008 onwards even
   though the reanalysis exists up to 2012.
   2016-01-04 Add support for the three hourly output data for the 19.0
   and 19.1 experiments.
   2016-07-06 Add new data sets from the HYCOM server (post-2014).
   2017-01-26 Use ncread to download the data to automatically apply the
   scale and offset values from the server data. At some point (either in
   HYCOM's server upgrades or MATLAB updates), values being returned for
   2005 were raw values (not scaled and offset), which is obviously wrong.

==========================================================================</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function url = get_url(time, threehourly)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data = get_HYCOM_forcing(Mobj, modelTime, varargin)</a>
0002 <span class="comment">% Get mean flow, temperature, salinity, surface elevation and denstiy data</span>
0003 <span class="comment">% from HYCOM model outputs through their OPeNDAP server.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% data = get_HYCOM_forcing(Mobj, modelTime)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% DESCRIPTION:</span>
0008 <span class="comment">%   Using OPeNDAP, extract the necessary parameters to create an FVCOM</span>
0009 <span class="comment">%   forcing file.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% INPUT:</span>
0012 <span class="comment">%   Mobj - MATLAB mesh object with the following fields:</span>
0013 <span class="comment">%           - have_lonlat - boolean indicating whether lat/long values are</span>
0014 <span class="comment">%           present in Mobj.</span>
0015 <span class="comment">%           - lon, lat - longitude and latitudes of the model grid nodes.</span>
0016 <span class="comment">%   modelTime - Modified Julian Date start and end times</span>
0017 <span class="comment">%   varlist - [optional] cell array of variables to download. Use HYCOM</span>
0018 <span class="comment">%       names (e.g. ssh, salinity, temperature, u, v). If omitted,</span>
0019 <span class="comment">%       downloads salinity, temperature and ssh only.</span>
0020 <span class="comment">%   three - [optional] boolean. Set to true to download the 3 hourly data</span>
0021 <span class="comment">%       for the period 1992/10/2 to 2008/09/18 (inclusive). Defaults to</span>
0022 <span class="comment">%       false and downloads only the daily data.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% OUTPUT:</span>
0025 <span class="comment">%   data - struct of the data necessary to force FVCOM. These can be</span>
0026 <span class="comment">%   interpolated onto the unstructured grid in Mobj using grid2fvcom.m.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The parameters (and the corresponding field names returned) which are</span>
0029 <span class="comment">% obtained from the HYCOM data are:</span>
0030 <span class="comment">%     - time [MT]</span>
0031 <span class="comment">%     - temperature [temperature]</span>
0032 <span class="comment">%     - salinity [salinity]</span>
0033 <span class="comment">%     - u mean flow component [u]</span>
0034 <span class="comment">%     - v mean flow component [v]</span>
0035 <span class="comment">%     - daily mean sea surface height [ssh]</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% EXAMPLE USAGE:</span>
0038 <span class="comment">%   To download the default parameters (temperature, salinity and ssh):</span>
0039 <span class="comment">%</span>
0040 <span class="comment">%       modeltime = [55561, 55591]; % time period in Modified Julian Days</span>
0041 <span class="comment">%       hycom = get_HYCOM_forcing(Mobj, modeltime);</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   To download only sea surface height:</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%       modeltime = [55561, 55591]; % time period in Modified Julian Days</span>
0046 <span class="comment">%       hycom = get_HYCOM_forcing(Mobj, modeltime, {'ssh'})</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Author(s)</span>
0049 <span class="comment">%   Pierre Cazenave (Plymouth Marine Laboratory)</span>
0050 <span class="comment">%</span>
0051 <span class="comment">% Revision history:</span>
0052 <span class="comment">%   2013-01-31 First version.</span>
0053 <span class="comment">%   2013-08-19 Make some more progress in getting this working. Mainly</span>
0054 <span class="comment">%   change the way the dates are handled to form the relevant URL for</span>
0055 <span class="comment">%   downloading the data.</span>
0056 <span class="comment">%   2013-09-03 More incremetal changes to get the function working. At the</span>
0057 <span class="comment">%   moment, I'm ignoring the old OPeNDAP toolbox for reading the data from</span>
0058 <span class="comment">%   the HYCOM OPeNDAP server.</span>
0059 <span class="comment">%   2013-09-05 It's working! Also add a data.time variable with the time</span>
0060 <span class="comment">%   stamps from the HYCOM data.</span>
0061 <span class="comment">%   2013-12-02 Add sea surface height to the list of variables that can be</span>
0062 <span class="comment">%   downloaded.</span>
0063 <span class="comment">%   2013-12-09 Add ability to specify particular variables to download.</span>
0064 <span class="comment">%   2013-12-12 Fix the handling of the variable input list of field names.</span>
0065 <span class="comment">%   2015-05-21 Add support for the Global Reanalysis data which extends</span>
0066 <span class="comment">%   coverage back to 1992 (previously limited to 2008 with the Global</span>
0067 <span class="comment">%   Analysis data). The Global Analysis data is used from 2008 onwards even</span>
0068 <span class="comment">%   though the reanalysis exists up to 2012.</span>
0069 <span class="comment">%   2016-01-04 Add support for the three hourly output data for the 19.0</span>
0070 <span class="comment">%   and 19.1 experiments.</span>
0071 <span class="comment">%   2016-07-06 Add new data sets from the HYCOM server (post-2014).</span>
0072 <span class="comment">%   2017-01-26 Use ncread to download the data to automatically apply the</span>
0073 <span class="comment">%   scale and offset values from the server data. At some point (either in</span>
0074 <span class="comment">%   HYCOM's server upgrades or MATLAB updates), values being returned for</span>
0075 <span class="comment">%   2005 were raw values (not scaled and offset), which is obviously wrong.</span>
0076 <span class="comment">%</span>
0077 <span class="comment">%==========================================================================</span>
0078 
0079 subname = <span class="string">'get_HYCOM_forcing'</span>;
0080 
0081 <span class="keyword">global</span> ftbverbose;
0082 <span class="keyword">if</span> ftbverbose
0083     fprintf(<span class="string">'\nbegin : %s\n'</span>, subname)
0084 <span class="keyword">end</span>
0085 
0086 <span class="comment">% For checking whether to use the third-party OPeNDAP toolbox or native</span>
0087 <span class="comment">% MATLAB tools. OPeNDAP support is included in MATLAB version 7.14 onwards.</span>
0088 <span class="comment">% Although this check is made, I haven't actually written the code for the</span>
0089 <span class="comment">% third-party toolbox. If you need it, I be pleased if you wrote an</span>
0090 <span class="comment">% equivalent to the native version.</span>
0091 v714date = datenum(2012, 3, 1);
0092 currdate = ver(<span class="string">'MATLAB'</span>);
0093 currdate = datenum(currdate.Date);
0094 
0095 <span class="keyword">if</span> datenum(currdate) &lt; v714date
0096     error([<span class="string">'This version of MATLAB does not have native OPeNDAP '</span>, <span class="keyword">...</span>
0097         <span class="string">'support and this function relies on that support. If you '</span>, <span class="keyword">...</span>
0098         <span class="string">'require this function, you will have to add the '</span>, <span class="keyword">...</span>
0099         <span class="string">'functionality with the third-party OPeNDAP toolbox.'</span>])
0100 <span class="keyword">end</span>
0101 
0102 <span class="comment">% Check if we've been given a cell array of variables and set the varlist</span>
0103 <span class="comment">% to that, otherwise default to temperature, salinity and sea surface</span>
0104 <span class="comment">% height. For the three option, assume we want daily data unless three is</span>
0105 <span class="comment">% true, in which case set the threehourly parameter to be the string</span>
0106 <span class="comment">% required for the THREDDS URL (/3hrly), otherwise default to daily data.</span>
0107 threehourly = <span class="string">''</span>;
0108 <span class="keyword">if</span> nargin == 2 || nargin &gt; 3
0109     varlist = {<span class="string">'temperature'</span>, <span class="string">'salinity'</span>, <span class="string">'ssh'</span>};
0110 <span class="keyword">end</span>
0111 <span class="keyword">if</span> nargin &gt; 2
0112     <span class="comment">% To maintain backwards compatibility, assume if we've been given a</span>
0113     <span class="comment">% cell array as the third option, that's the variables to download.</span>
0114     <span class="comment">% Otherwise, iterate through the argument as key-parameter pairs.</span>
0115     <span class="keyword">if</span> nargin == 3
0116         <span class="keyword">if</span> iscell(varargin{1})
0117             varlist = varargin{1};
0118             assert(iscell(varargin{1}), [<span class="keyword">...</span>
0119                 <span class="string">'List of variables to extract must'</span>, <span class="keyword">...</span>
0120                 <span class="string">' be a cell array: {''var1'', ''var2''}'</span>])
0121         <span class="keyword">end</span>
0122     <span class="keyword">else</span>
0123         <span class="keyword">for</span> v = 1:2:length(varargin)
0124             <span class="keyword">switch</span> varargin{v}
0125                 <span class="keyword">case</span> <span class="string">'three'</span>
0126                     <span class="keyword">if</span> varargin{v + 1}
0127                         threehourly = <span class="string">'/3hrly'</span>;
0128                     <span class="keyword">end</span>
0129                     <span class="keyword">if</span> modelTime(1) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0130                         error([<span class="string">'The three hourly output is not '</span>, <span class="keyword">...</span>
0131                                 <span class="string">'configured for the period beyond '</span>, <span class="keyword">...</span>
0132                                 <span class="string">'2008/09/18 in this function. Please '</span>, <span class="keyword">...</span>
0133                                 <span class="string">'disable three hourly downloads, or '</span>, <span class="keyword">...</span>
0134                                 <span class="string">'edit this function to suit your needs.'</span>])
0135                     <span class="keyword">end</span>
0136             <span class="keyword">end</span>
0137         <span class="keyword">end</span>
0138     <span class="keyword">end</span>
0139 <span class="keyword">end</span>
0140 
0141 <span class="comment">% Get the extent of the model domain (in spherical).</span>
0142 <span class="keyword">if</span> ~Mobj.have_lonlat
0143     error(<span class="string">'Need spherical coordinates to extract the forcing data'</span>)
0144 <span class="keyword">else</span>
0145     <span class="comment">% Add a buffer of two grid cells in latitude and two in longitude to</span>
0146     <span class="comment">% make sure the model domain is fully covered by the extracted data.</span>
0147     [dx, dy] = deal(1/12, 1/12); <span class="comment">% HYCOM resolution in degrees</span>
0148     <span class="comment">% West, east, south, north</span>
0149     extents = [min(Mobj.lon(:)) - (2 * dx), max(Mobj.lon(:)) + (2 * dx), <span class="keyword">...</span>
0150         min(Mobj.lat(:)) - (2 * dy), max(Mobj.lat(:)) + (2 * dy)];
0151 <span class="keyword">end</span>
0152 
0153 <span class="comment">% List of URL suffixes so we can dynamically build the URL for each time</span>
0154 <span class="comment">% step.</span>
0155 suffix.MT           = {<span class="string">'time'</span>, <span class="string">'MT'</span>};
0156 suffix.Longitude    = {<span class="string">'lon'</span>, <span class="string">'Longitude'</span>};
0157 suffix.Latitude     = {<span class="string">'lat'</span>, <span class="string">'Latitude'</span>};
0158 suffix.Depth        = {<span class="string">'depth'</span>, <span class="string">'Depth'</span>};
0159 suffix.temperature  = {<span class="string">'water_temp'</span>, <span class="string">'temperature'</span>};
0160 suffix.salinity     = {<span class="string">'salinity'</span>, <span class="string">'salinity'</span>};
0161 suffix.u            = {<span class="string">'water_u'</span>, <span class="string">'u'</span>};
0162 suffix.v            = {<span class="string">'water_v'</span>, <span class="string">'v'</span>};
0163 suffix.ssh          = {<span class="string">'surf_el'</span>, <span class="string">'ssh'</span>};
0164 
0165 <span class="comment">% Get the URL to use for the first time step.</span>
0166 url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(modelTime(1), threehourly);
0167 
0168 <span class="keyword">if</span> modelTime(1) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0169     name_index = 1;
0170 <span class="keyword">elseif</span> modelTime(1) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0171     name_index = 2;
0172 <span class="keyword">end</span>
0173 hycom.MT            = [url, suffix.MT{name_index}];          <span class="comment">% time [1D]</span>
0174 hycom.Longitude     = [url, suffix.Longitude{name_index}];   <span class="comment">% [2D]</span>
0175 hycom.Latitude      = [url, suffix.Latitude{name_index}];    <span class="comment">% [2D]</span>
0176 hycom.Depth         = [url, suffix.Depth{name_index}];       <span class="comment">% water depth [2D]</span>
0177 hycom.temperature   = [url, suffix.temperature{name_index}]; <span class="comment">% [4D]</span>
0178 hycom.salinity      = [url, suffix.salinity{name_index}];    <span class="comment">% [4D]</span>
0179 hycom.ssh           = [url, suffix.ssh{name_index}];         <span class="comment">% sea surface height [3D]</span>
0180 hycom.u             = [url, suffix.u{name_index}];           <span class="comment">% mean flow [4D]</span>
0181 hycom.v             = [url, suffix.v{name_index}];           <span class="comment">% mean flow [4D]</span>
0182 
0183 <span class="comment">% Load the depth data (1D vector).</span>
0184 ncid = netcdf.open(hycom.Depth, <span class="string">'NOWRITE'</span>);
0185 <span class="keyword">try</span>
0186     varid = netcdf.inqVarID(ncid, <span class="string">'Depth'</span>);
0187 <span class="keyword">catch</span>
0188     varid = netcdf.inqVarID(ncid, <span class="string">'depth'</span>);
0189 <span class="keyword">end</span>
0190 
0191 <span class="comment">% HYCOM has fixed depths, so the array which returned here is just</span>
0192 <span class="comment">% a list of those depths. We need them to interpolate the vertical</span>
0193 <span class="comment">% structure onto the FVCOM sigma levels.</span>
0194 data.Depth.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0195 
0196 netcdf.close(ncid)
0197 
0198 <span class="comment">% Get the number of vertical levels.</span>
0199 nz = length(data.Depth.data);
0200 
0201 <span class="comment">% Set a time increment is we've got the three-hourly flag passed to the</span>
0202 <span class="comment">% function. At some point, this may have to be a string comparison such</span>
0203 <span class="comment">% that we can use different outputs (if the HYCOM folks add them), but for</span>
0204 <span class="comment">% now, we just assume non-empty strings means three-hourly data. This will</span>
0205 <span class="comment">% also break horribly if we request data from both daily and three-hourly</span>
0206 <span class="comment">% data sets.</span>
0207 <span class="keyword">if</span> ~isempty(threehourly)
0208     time_increment = 3/24;
0209 <span class="keyword">else</span>
0210     time_increment = 1;
0211 <span class="keyword">end</span>
0212 times = modelTime(1):time_increment:modelTime(2);
0213 nt = length(times);
0214 
0215 <span class="comment">% Before we go off downloading data, check the variables we've been asked</span>
0216 <span class="comment">% for are actually valid HYCOM names.</span>
0217 <span class="keyword">for</span> vv = 1:length(varlist)
0218     <span class="keyword">if</span> iscell(varlist) &amp;&amp; ~isfield(hycom, varlist{vv})
0219         error(<span class="string">'Variable %s is not a valid HYCOM variable name.'</span>, varlist{vv})
0220     <span class="keyword">end</span>
0221 <span class="keyword">end</span>
0222 
0223 <span class="comment">% Initialise the value of url so we can compare it each loop and only</span>
0224 <span class="comment">% reopen the connection to the server if we've crossed into a different</span>
0225 <span class="comment">% data set.</span>
0226 url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(modelTime(1), threehourly);
0227 
0228 data.time = [];
0229 c = 1; <span class="comment">% counter for the tmjd cell array.</span>
0230 <span class="keyword">for</span> tt = 1:nt
0231 
0232     <span class="comment">% So we can use either the Reanalysis (pre-2008) or Analysis</span>
0233     <span class="comment">% (post-2008) data, we need to build the request struct based on the</span>
0234     <span class="comment">% current time.</span>
0235 
0236     <span class="comment">% Set up a struct of the HYCOM data sets in which we're interested.</span>
0237     <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0238         name_index = 1;
0239     <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0240         name_index = 2;
0241     <span class="keyword">end</span>
0242     hycom.MT            = [url, suffix.MT{name_index}];          <span class="comment">% time [1D]</span>
0243     hycom.Longitude     = [url, suffix.Longitude{name_index}];   <span class="comment">% [2D]</span>
0244     hycom.Latitude      = [url, suffix.Latitude{name_index}];    <span class="comment">% [2D]</span>
0245     hycom.Depth         = [url, suffix.Depth{name_index}];       <span class="comment">% water depth [2D]</span>
0246     hycom.temperature   = [url, suffix.temperature{name_index}]; <span class="comment">% [4D]</span>
0247     hycom.salinity      = [url, suffix.salinity{name_index}];    <span class="comment">% [4D]</span>
0248     hycom.ssh           = [url, suffix.ssh{name_index}];         <span class="comment">% sea surface height [3D]</span>
0249     hycom.u             = [url, suffix.u{name_index}];           <span class="comment">% mean flow [4D]</span>
0250     hycom.v             = [url, suffix.v{name_index}];           <span class="comment">% mean flow [4D]</span>
0251 
0252     oldurl = url;
0253     url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(times(tt), threehourly);
0254     <span class="comment">% Only reopen the connection if the two URLs differ.</span>
0255     <span class="keyword">if</span> ~strcmpi(oldurl, url) || tt == 1
0256         <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0257             hycom.MT = [url, suffix.MT{1}];
0258         <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0259             hycom.MT = [url, suffix.MT{2}];
0260         <span class="keyword">end</span>
0261         ncid = netcdf.open(hycom.MT, <span class="string">'NOWRITE'</span>);
0262         <span class="keyword">try</span>
0263             varid = netcdf.inqVarID(ncid, <span class="string">'MT'</span>);
0264         <span class="keyword">catch</span>
0265             varid = netcdf.inqVarID(ncid, <span class="string">'time'</span>);
0266         <span class="keyword">end</span>
0267 
0268         <span class="comment">% Add the new data to the cell array. This should build up an</span>
0269         <span class="comment">% array of unique time series. We can then use these to query</span>
0270         <span class="comment">% for the time indices for each time step later.</span>
0271         data.MT.data{c} = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0272 
0273         netcdf.close(ncid)
0274 
0275         <span class="comment">% Convert to Gregorian date and then to Modified Julian Days. The</span>
0276         <span class="comment">% Global Reanalysis stores time as hours since 2000-01-01, the</span>
0277         <span class="comment">% Global Analysis as days since 1900-12-31.</span>
0278         <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0279             t{c} = datevec((data.MT.data{c} / 24) + datenum(2000, 1, 1, 0, 0, 0));
0280         <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0281             t{c} = datevec(data.MT.data{c} + datenum(1900, 12, 31, 0, 0, 0));
0282         <span class="keyword">end</span>
0283         tmjd{c} = greg2mjulian(t{c}(:,1), t{c}(:,2), t{c}(:,3), t{c}(:,4), t{c}(:,5), t{c}(:,6));
0284 
0285         c = c + 1;
0286     <span class="keyword">end</span>
0287 <span class="keyword">end</span>
0288 
0289 <span class="comment">% Open the relevant spatial variables on the remote server and download the</span>
0290 <span class="comment">% spatial data required to subset the HYCOM data.</span>
0291 ncid = netcdf.open(hycom.Longitude, <span class="string">'NOWRITE'</span>);
0292 <span class="keyword">try</span>
0293     varid = netcdf.inqVarID(ncid, suffix.Longitude{1});
0294 <span class="keyword">catch</span>
0295     varid = netcdf.inqVarID(ncid, suffix.Longitude{2});
0296 <span class="keyword">end</span>
0297 
0298 data.X.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0299 
0300 netcdf.close(ncid)
0301 
0302 <span class="comment">% Make the longitude values in the range -180 to 180 (to match the</span>
0303 <span class="comment">% model inputs).</span>
0304 data.X.data = mod(data.X.data, 360);
0305 data.X.data(data.X.data &gt; 180) = data.X.data(data.X.data &gt; 180) - 360;
0306 
0307 ncid = netcdf.open(hycom.Latitude, <span class="string">'NOWRITE'</span>);
0308 <span class="keyword">try</span>
0309     varid = netcdf.inqVarID(ncid, suffix.Latitude{1});
0310 <span class="keyword">catch</span>
0311     varid = netcdf.inqVarID(ncid, suffix.Latitude{2});
0312 <span class="keyword">end</span>
0313 
0314 data.Y.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0315 
0316 netcdf.close(ncid)
0317 
0318 <span class="comment">% If the spatial data are vectors, turn them in to matrices here.</span>
0319 <span class="keyword">if</span> isvector(data.X.data) &amp;&amp; isvector(data.Y.data)
0320     [data.X.data, data.Y.data] = meshgrid(data.X.data, data.Y.data);
0321     <span class="comment">% Orient the arrays as required for the calls to the remote server.</span>
0322     data.X.data = data.X.data';
0323     data.Y.data = data.Y.data';
0324 <span class="keyword">end</span>
0325 
0326 <span class="comment">% Create indices of the size of the arrays.</span>
0327 data.X.idx = repmat(1:size(data.X.data, 1), [size(data.X.data, 2), 1])';
0328 data.Y.idx = repmat(1:size(data.Y.data, 2), [size(data.Y.data, 1), 1]);
0329 <span class="comment">%data.Y.idx = 1:size(data.Y.data, 2) - 1;</span>
0330 
0331 <span class="comment">% Find the indices which cover the model domain then find the extremes to</span>
0332 <span class="comment">% request only a subset from the OPeNDAP server.</span>
0333 idx = data.X.data &gt; extents(1) &amp; data.X.data &lt; extents(2) &amp; data.Y.data &gt; extents(3) &amp; data.Y.data &lt; extents(4);
0334 xrange = [min(data.X.idx(idx)), max(data.X.idx(idx))];
0335 yrange = [min(data.Y.idx(idx)), max(data.Y.idx(idx))];
0336 
0337 data.lon = data.X.data(xrange(1):xrange(2), yrange(1):yrange(2));
0338 data.lat = data.Y.data(xrange(1):xrange(2), yrange(1):yrange(2));
0339 
0340 <span class="comment">% Clear out the full lon/lat arrays.</span>
0341 <span class="comment">% data = rmfield(data, {'X', 'Y'});</span>
0342 
0343 <span class="comment">% Now get the variables for which we've been asked.</span>
0344 fields = varlist;
0345 
0346 <span class="keyword">for</span> aa = 1:length(fields)
0347     <span class="comment">% Store the downloaded data in a struct. Assume the spatial</span>
0348     <span class="comment">% data is identical to that in data.lon and data.lat.</span>
0349     data.(fields{aa}).data = [];
0350 
0351     ncid = netcdf.open(hycom.(fields{aa}));
0352     varid = netcdf.inqVarID(ncid, suffix.(fields{aa}){name_index});
0353 
0354     <span class="comment">% If you don't know what it contains, start by using the</span>
0355     <span class="comment">% 'netcdf.inq' and ncinfo operations:</span>
0356     <span class="comment">%[numdims, numvars, numglobalatts, unlimdimid] = netcdf.inq(ncid);</span>
0357     <span class="comment">%ncid_info = ncinfo(hycom.(fields{aa}));</span>
0358 
0359     <span class="comment">% Typically these data are 4D, with dimensions of:</span>
0360     <span class="comment">%   - x (X)</span>
0361     <span class="comment">%   - y (Y)</span>
0362     <span class="comment">%   - depth (Depth)</span>
0363     <span class="comment">%   - time (MT)</span>
0364     <span class="comment">% except in the case of sea surface height, where we lose</span>
0365     <span class="comment">% the depth dimension. For all other variables, we want all</span>
0366     <span class="comment">% depths but only a subset in time and space.</span>
0367 
0368     <span class="comment">% Since the HYCOM OPeNDAP server is so spectacularly slow,</span>
0369     <span class="comment">% extract a day's data at a time and stick them together</span>
0370     <span class="comment">% here. If nothing else, this at least means I can give</span>
0371     <span class="comment">% some indication of progress, rather than just wait for</span>
0372     <span class="comment">% something to eventually happen.</span>
0373     nx = (xrange(2) - xrange(1)) + 1;
0374     ny = (yrange(2) - yrange(1)) + 1;
0375 
0376     <span class="comment">% Preallocate the output so we don't append to an array</span>
0377     <span class="comment">% (which is slow). Sea surface height is 3D only (all the</span>
0378     <span class="comment">% other variables are 4D). So, it needs its own little</span>
0379     <span class="comment">% check all to itself.</span>
0380     <span class="keyword">if</span> strcmpi(fields{aa}, <span class="string">'ssh'</span>) == 1
0381         was_zeta = true; <span class="comment">% set boolean for surface elevation</span>
0382         data.(fields{aa}).data = nan(nx, ny, nt);
0383     <span class="keyword">else</span>
0384         was_zeta = false;
0385         data.(fields{aa}).data = nan(nx, ny, nz, nt);
0386     <span class="keyword">end</span>
0387 
0388     c = 0; <span class="comment">% counter for iterating through tmjd.</span>
0389 
0390     <span class="keyword">for</span> tt = 1:nt
0391         <span class="keyword">if</span> ftbverbose
0392             fprintf(<span class="string">'%s: time %i of %i... '</span>, fields{aa}, tt, nt)
0393         <span class="keyword">end</span>
0394 
0395         <span class="comment">% Get the current url value for this time step. This</span>
0396         <span class="comment">% approach means we can grab data which straddles a</span>
0397         <span class="comment">% boundary between HYCOM outputs. Only reopen the</span>
0398         <span class="comment">% connection if the url value has changed. At this</span>
0399         <span class="comment">% point we also need to get ourselves a new time index</span>
0400         <span class="comment">% using modelTime and the cell array tmjd.</span>
0401         oldurl = url;
0402         url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(times(tt), threehourly);
0403 
0404         <span class="keyword">if</span> ~strcmpi(oldurl, url) || tt == 1
0405             <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0406                 hycom.(fields{aa}) = [url, suffix.(fields{aa}){1}];
0407             <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0408                 hycom.(fields{aa}) = [url, suffix.(fields{aa}){2}];
0409             <span class="keyword">end</span>
0410             c = c + 1;
0411         <span class="keyword">end</span>
0412 
0413         <span class="comment">% Find the time index closest to the current model</span>
0414         <span class="comment">% time.</span>
0415         [~, ts] = min(abs(tmjd{c} - times(tt)));
0416 
0417         <span class="keyword">if</span> was_zeta
0418             <span class="comment">% netCDF starts at zero, hence -1.</span>
0419             start = [xrange(1), yrange(1), ts] - 1;
0420             count = [nx, ny, 1];
0421             data.(fields{aa}).data(:, :, tt) = ncread(url, suffix.(fields{aa}){name_index}, start + 1, count);
0422         <span class="keyword">else</span>
0423             <span class="comment">% netCDF starts at zero, hence -1.</span>
0424             start = [xrange(1), yrange(1), 1, ts] - 1;
0425             count = [nx, ny, nz, 1];
0426             data.(fields{aa}).data(:, :, :, tt) = ncread(url, suffix.(fields{aa}){name_index}, start + 1, count);
0427         <span class="keyword">end</span>
0428 
0429         <span class="comment">% Build an array of the HYCOM times. Only do so once so</span>
0430         <span class="comment">% we don't end up appending it multiple times.</span>
0431         <span class="keyword">if</span> length(data.time) &lt; nt
0432             data.time = [data.time; tmjd{c}(ts)];
0433         <span class="keyword">end</span>
0434 
0435         <span class="keyword">if</span> ftbverbose; fprintf(<span class="string">'done.\n'</span>); <span class="keyword">end</span>
0436     <span class="keyword">end</span>
0437     netcdf.close(ncid);
0438 <span class="keyword">end</span>
0439 
0440 <span class="keyword">if</span> ftbverbose
0441     fprintf(<span class="string">'end   : %s\n'</span>, subname)
0442 <span class="keyword">end</span>
0443 
0444 <a name="_sub1" href="#_subfunctions" class="code">function url = get_url(time, threehourly)</a>
0445 <span class="comment">% Child function to find the relevant URL to use for a given time step.</span>
0446 <span class="comment">%</span>
0447 <span class="comment">% url = get_url(time, threehourly);</span>
0448 <span class="comment">%</span>
0449 <span class="comment">% INPUT:</span>
0450 <span class="comment">%   time - Modified Julian Day</span>
0451 <span class="comment">%   threehourly - additional string to append for optional three hourly</span>
0452 <span class="comment">%   outputs for the 1992/10/02 to 2008/09/18 period. Leave empty for daily</span>
0453 <span class="comment">%   data.</span>
0454 <span class="comment">%</span>
0455 <span class="comment">% OUTPUT:</span>
0456 <span class="comment">%   url - string of the approprate URL for the date supplied in time.</span>
0457 <span class="comment">%</span>
0458 
0459 [t1, t2, t3, t4, t5, t6] = datevec(datestr(now));
0460 
0461 <span class="keyword">if</span> time &lt; greg2mjulian(1992, 10, 2, 0, 0, 0)
0462     error(<span class="string">'No HYCOM data available prior to 1992-10-02. Select a start date from 1992-10-02 onwards.'</span>)
0463 <span class="keyword">elseif</span> time &gt;= greg2mjulian(1992, 10, 2, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(1995, 7, 31, 0, 0, 0)
0464     warning(<span class="string">'Using the HYCOM Global Reanalysis data for dates up to 2008/09/16, thereafter the Global Analysis.'</span>)
0465     url = sprintf(<span class="string">'http://tds.hycom.org/thredds/dodsC/GLBu0.08/expt_19.0%s?'</span>, threehourly);
0466 <span class="keyword">elseif</span> time &gt;= greg2mjulian(1995, 7, 31, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0467     warning(<span class="string">'Using the HYCOM Global Reanalysis data for dates up to 2008/09/16, thereafter the Global Analysis.'</span>)
0468     url = sprintf(<span class="string">'http://tds.hycom.org/thredds/dodsC/GLBu0.08/expt_19.1%s?'</span>, threehourly);
0469 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2008, 9, 19, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2009, 5, 7, 0, 0, 0)
0470     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.6?'</span>;
0471 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2009, 5, 7, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2011, 1, 3, 0, 0, 0)
0472     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.8?'</span>;
0473 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2011, 1, 3, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2013, 8, 21, 0, 0, 0)
0474     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.9?'</span>;
0475 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2013, 8, 21, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2014, 4, 21, 0, 0, 0)
0476     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.0?'</span>;
0477 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2014, 4, 21, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2016, 4, 18, 0, 0, 0)
0478     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.1?'</span>;
0479 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2016, 4, 18, 0, 0, 0) &amp;&amp; time &lt;= greg2mjulian(t1, t2, t3, t4, t5, t6)
0480     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.2?'</span>;
0481 <span class="keyword">elseif</span> time &gt; greg2mjulian(t1, t2, t3, t4, t5, t6)
0482     error(<span class="string">'Given date is in the future.'</span>)
0483 <span class="keyword">else</span>
0484     error(<span class="string">'Date is outside of the known spacetime continuum. See help TARDIS.'</span>)
0485 <span class="keyword">end</span>
0486</pre></div>
<hr><address>Generated on Wed 20-Feb-2019 16:06:01 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>